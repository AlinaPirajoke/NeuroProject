import streamlit as st
from PIL import Image

st.header("Как обучаются нейросети")
st.subheader("Принцип работы нейронных сетей: ")
st.write("Для того чтобы понять как нейросети обучать, сперва нужно выяснить как они работают, хотя бы как работает классическая структура. В общих чертах, принцип работы нейронных сетей можно обозначить как процесс многократной обработки и преобразования входящей информации.  ")
st.write("Как же эта информация преобразуется? Всё дело в весах, связывающих нейроны. Эти весы имеют каждый своё значение, на которое умножается информация (тоже числовое значение), подаваемая от предыдущего нейрона к принимающему. Так как каждый нейрон (кроме входных) связан со всеми нейронами предыдущего, значение нейрона рассчитываются как сумма произведений значений всех нейронов предыдущего ряда (входного) на веса, которыми он с ними связан. Также к итоговой сумме могут применяться различные манипуляции, в зависимости от задач нейросети.")

st.subheader("Рассмотрим этот процесс поподробнее:")
with Image.open("nn2.jpg") as f:
    st.image(f)
    st.caption("Рассмотрим порядок работы на примере эиой схемы нейронной сети")
st.write("Взгляните на рисунок, кружочками обозначены нейроны, линиями веса, а стрелочки характеризуют поступающую и выходную информацию. По схеме видно, что каждый нейрон входного слоя связан весами (w) с каждым нейроном скрытого. Также связан скрытый слой и выходной. Если бы у нас было, к примеру, два скрытых слоя, связь между ними была бы такая же. ")
st.write("По стрелочкам видно, что в нейросеть что-то поступает, это набор чисел, характеризующих что-либо. Информация поступает во входной слой нейронов, с этого начинаются расчёты. Значения из каждого нейрона входного слоя передаются на каждый нейрон следующего слоя, умножаясь на веса между ними (как уже было сказано ранее они имеют разные значения). К примеру, на нейрон 1 скрытого слоя подаются значения всех n предыдущих (входных) нейронов, умноженных на n весов, соединяющих, соответственно, наш нейрон со входными нейронами. После все эти произведения складываются. Это удобно представлять как произведение матрицы значений входных нейронов (X) на матрицу весов (W). После этого к сумме прибавляется уже значение, заданное в самом нейроне (b) и от всего этого вычисляется “функция активации” (f()) которая может быть разной. Математически это можно записать как x = f(X*W + b), где х - рассчитываемое значение. Готово, мы получили значение в нейроне, теперь его можно подавать на вход следующему слою! ")
st.write("И вся эта работа проводится для каждого нейрона каждого слоя после входного. После прохождения всех слоёв, итоговые значения можно взять из выходного слоя. В на рисунке изображена классифицирующая модель, так что значение на каждом из выходных нейронов, будет обозначать принадлежность к тому или иному классу. На каком нейроне значение больше, к тому классу и принадлежит объект, который характеризуют входные данные. Правда, как магия? ")
st.write("Разные виды нейронных сетей могут по-своему изменять этот процесс. Бывают “круговые” схемы нейронных сетей, схемы, где нейроны передают значения сами себе же и много других интересных решений.")

st.subheader("Как обучать нейросети ")
st.info("Обучение нейросети — это целая наука, ключевой момент в её создании. ")
st.write("Как говорилось в вышеописанном принципе работы нейросети, для каждого нейрона матрица входных нейронов умножается на матрицу весов. Значения входных нейронов известны, при расчёте значений первого скрытого слоя — это входные данные, на следующих слоях это предыдущие слои, но откуда же взять веса? При случайных значениях весов нейросеть будет выводить случайные значения и будет бесполезной. Именно в нахождении тех весов, при которых система будет максимально точна и заключается задача обучения. ")
st.write("Рассмотрим стандартный вариант обучения — с учителем. ")
st.write("В начале необходимо некоторое множество данных (его размер зависит от целевой точности модели) на котором будет обучаться нейросеть — датасет. Где найти или как собрать датасет можно узнать на нашем сайте. Датасет разбивают на две выборки - тренировочную и тестовую, это нужно для того, чтобы можно было испытать нейросеть на данных, которые она прежде не видела. ")
st.write("Сначала все значения весов берутся случайными. В ходе обучения в нейросеть раз за разом передаются тестовые последовательности данных, и сравниваются её ответы и правильные. Оценивая их, и применяя разные методы сравнения (функции потерь) можно вычислить на сколько она ошиблась. Это значение так и называют, “Ошибкой”.  ")
st.write("Основываясь этой ошибке, и применяя определённый метод, слой за слоем изменяют значения весов. Методы, которыми рассчитываются изменения весов, могут быть разными, классическим считается “Метод обратного распространения” или “backpropagation”, иногда используются и другие. Разбор этих методов довольно сложен и объёмен, информацию о нах можно найти в интернете.  ")
st.write("Испытания и исправления поочерёдно продолжаются по всей тренировочной выборке несколько раз, пока нейросеть не сможет выполнять свою задачу с требуемой точностью. Однако здесь нужно быть осторожным, и использовать достаточно большие по объёму наборы тренировочных данных — нейросеть может просто “запомнить” каждый отдельный пример и, хоть её точность на тренировке и будет высокая, на новых данных, не известных ей, точность будет низкой. ")
st.write("Если добиться желаемой точности не удаётся несмотря на длительное время обучения, значит какой-то элемент подобран неправильно. Возможно, датасет некачественный или недостаточно большой, возможно следует изменить функцию активации, добавить или наоборот уменьшить количество слоёв (в случае переобучения) или даже изменить тип нейросети (возможно он выбран неправильно. Нужно поэкспериментировать с вариантами и найти наилучший. ")
st.write("После обучения следует проверить нейросеть на тестовой выборке или даже на данных, не присутствовавших в датасете. Модель также можно доучивать и дорабатывать уже в процессе использования  ")