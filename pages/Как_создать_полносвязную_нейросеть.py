import streamlit as st
from PIL import Image

st.header('Как построить и обучить полносвязную нейронную сеть на своём наборе данных')
st.write("Полносвязные нейронныя сети используются в случае, когда по имеющемуся у вас набору признаков нужно определить какому объекту (классу) они принадлежат. То есть задача нейросети выбрать один из имеющихся вариантов, опираясь на предоставленное ей описание свойств. ")
st.write("Примеры в дальнейшей инструкции показывают создание нейросети для классификации вида ириса по его параметрам. Это классическое задание многоклассовой классификации, где имеется три класса — три вида ириса. ")
st.subheader("Открытие Сolaboratory")
st.write("Прежде всего нужно обзавестись своим датасетом, набором данных, состоящих из признаков и правильных ответов. Представим, что датасет у вас уже есть, тогда следующим шагом будет создание нового блокнота в Google Сolaboratory. Для этого зайдите в своё хранилище Google Drive, нажмите “Создать” -> “Ещё” -> “Подключить другие приложения” и выберите “Сolaboratory”. ")
st.write("После создания нового блокнота нужно загрузить ваш датасет в сессионное хранилище. Для этого есть специальная кнопка слева сверху: ")
with Image.open("upload.png") as f:
    st.image(f)
st.subheader("Подготовка данных ")
st.info("Примеры в дальнейшей инструкции описывают процесс, основываясь на задаче классификации ирисов. Для вашего примера потребуется модифицировать предоставленный код, подставив значения в поля со звёздочкой. ")
st.write("Прежде всего нужно подключить используемые в дальнейшей работе библиотеки: ")
st.code('''# Подключение необходимых библиотек 
import numpy as np 
import pandas as pd 
import tensorflow as tf 
from tensorflow.keras import layers ''')
st.write("И импортировать наш датасет:  ")
st.code('''# Импорт своего датасета
df = pd.read_csv(Путь до файла датасета*, names = Перечень присваемых сролбцам имён*)
# Вывод первых 5 элементов для проверки
df.head()''')
but1 = st.button("Пример с ирисами")
if(but1):
    st.code('''
    # Импорт своего датасета
    df = pd.read_csv("/content/iris.data", names = ['sepal_l', 'sepal_W', 'petal_l', 'petal_w', 'sort'])
    # Вывод первых 5 элементов для проверки
    df.head()''')
st.write("В качестве аргументов функции pd.read_csv() мы передаём адрес файла с нашим набором данных (его можно получить, нажав правой кнопкой мыши по файлу в хранилище и скопировав путь) и название для столбцов данных, если оригинальные названия отсутствуют (Проверьте их наличие, открыв файл датасета) ")
st.write("Далее нам нужно разделить данные на два подмножества: для обучения и для проверки: ")
st.code('''# Разделение данных на два подмножества
train, test = np.split(df.sample(frac=1, random_state=42), 
                       [int(.9*len(df))])''')
st.write("Это нужно чтобы впоследствии проверить нейросеть на данных, которые она не видела ")
st.write("Также нужно разделить подмножества на признаки и правильные ответы для того, чтобы не давать ответы сразу и можно было оценить её собственные:")
st.code('''# Разделение тренировочных данных на признаки и ответы
train_x = train.copy()
# Укажите название признака, которая должна быть ответом
train_names = list(train_x.pop(имя признака-ответа*))
train_x = np.array(train_x)

# Разделение тестовых данных на признаки и ответы
test_x = test.copy()
test_names = list(test_x.pop(имя признака-ответа*))
test_x = np.array(test_x)''')
but2 = st.button("Пример с ирисами", key=2)
if(but2):
    st.code('''# Разделение тренировочных данных на признаки и ответы
    train_x = train.copy()
    train_names = list(train_x.pop('sort'))
    train_x = np.array(train_x)

    # Разделение тестовых данных на признаки и ответы
    test_x = test.copy()
    test_names = list(test_x.pop('sort'))
    test_x = np.array(test_x)''')
st.write("Пометкой x обычно обозначают входные данные, а пометкой y - ожидаемые выходные. ")
st.write("Поскольку в случае классификации вариантов ответов может быть множество, они, скорее всего, представлены в виде названия правильного класса. Нейросеть же, в свою очередь, должна иметь отдельные выходы под каждый вариант ответа, потому необходимо модифицировать массив ответов в матрицу со отдельными столбцами для каждого варианта. В случае, если ваша задача - не классификация, или ответ представляет из себя одно число, то следующий пункт можно пропустить. ")
st.code('''# Представление ответов в удобной для обучения нейросети форме
def toMatrix(names):
  matrix = np.zeros((len(names), Количество возможных ответов*))
  for n in range(len(names)): 
    if Первый возможный ответ (класс)* in names[n]: matrix[n][0] = 1
    elif Второй возможный ответ (класс)* in names[n]: matrix[n][1] = 1
    elif Третий возможный ответ (класс)* in names[n]: matrix[n][2] = 1
    ...
  return matrix

train_y = toMatrix(train_names)
test_y = toMatrix(test_names)

# Проверка результатов модифицирования данных
train_y''')
but3 = st.button("Пример с ирисами", key=3)
if(but3):
    st.code('''# Представление ответов в удобной для обучения нейросети форме
    def toMatrix(names):
      matrix = np.zeros((len(names), 3))
      for n in range(len(names)): 
        if 'Iris-setosa' in names[n]: matrix[n][0] = 1
        elif 'Iris-versicolor' in names[n]: matrix[n][1] = 1
        elif 'Iris-virginica' in names[n]: matrix[n][2] = 1
      return matrix

    train_y = toMatrix(train_names)
    test_y = toMatrix(test_names)

    # Проверка результатов модифицирования данных
    train_y''')
st.subheader("Построение и обучение нейросети ")
st.write("Для того, чтобы представить вводимые признаки в удобной для нейросети форме (от 0 до 1) и повысить характеристики нейросети, нужно провести процедуру нормализации ")
st.code('''# Нормализация входных данных
normalize = layers.Normalization()
normalize.adapt(train_x)''')
st.write("Теперь настало время описания модели. Для этого составьте следующую конструкцию: ")
st.code('''# Описание модели
Назввание модели* = tf.keras.Sequential([
  normalize,
  tf.keras.Input(shape= Количество входных признаков*),
  tf.keras.layers.Dense(20, activation='relu'),
  tf.keras.layers.Dense(Количество выходных признаков*, activation='softmax')
])''')
but4 = st.button("Пример с ирисами", key=4)
if(but4):
    st.code('''# Описание модели
    iris_model = tf.keras.Sequential([
      normalize,
      tf.keras.Input(shape=4),
      tf.keras.layers.Dense(20, activation='relu'),
      tf.keras.layers.Dense(3, activation='softmax')
    ])''')
st.write("Где строки, следующие после normalize - слои. На первом (входном) слое (там, где Input) нужно указать количество входящих признаков, а на последнем (выходном) количество вариантов ответов (или 1, если ответ - число). ")
st.write("После описания, модель нужно скомпилировать, чтобы ей можно было пользоваться: ")
st.code('''# Компиляция
Название модели*.compile(loss = tf.losses.MeanSquaredError(),
                      optimizer = tf.optimizers.Adam(),
                      metrics=['accuracy'])''')
but42 = st.button("Пример с ирисами", key=42)
if(but42):
    st.code('''# Компиляция
    iris_model.compile(loss = tf.losses.MeanSquaredError(),
                          optimizer = tf.optimizers.Adam(),
                          metrics=['accuracy'])''')
st.write("Необученная модель будет выдавать случайные результаты, и, чтобы она не была бесполезной её нужно натренировать на наших данных, для этого достаточно выполнить следующую строку: ")
st.code('''# Запуск процесса обучения модели
iris_model.fit(train_x, train_y, epochs=30, validation_data=(test_x, test_y)))''')
st.write("Где указываются входные данные и правильные ответы, а epochs - количество раз, которые ваши данные будут прогоняться через модель. Чем больше, тем лучше (и дольше), но если переборщить, то модель переобучится и её точность упадёт. Если датасет имеет большое количество наблюдений (записей) обучение может занять какое-то время. В случае если точность оказалась низкой (не устраивающей), модель можно обучить ещё несколько раз, но, опять же, не перебарщивайте, вследствие переобучения точность на обучающей выборке может отличаться от фактической. ")
st.subheader("Проверка обученной нейросети ")
st.write("Для того, чтобы узнать итоговые характеристики точности вашей нейросети можно выполнить следующую функцию: ")
st.code('''# Оценка характеристик точности модели
res = Название модели.evaluate(test_x, test_y)
print(res)''')
but5 = st.button("Пример с ирисами", key=5)
if(but5):
    st.code('''# Оценка характеристик точности модели
    res = iris_model.evaluate(test_x, test_y)
    print(res)''')
st.write("Если же вы хотите использовать вашу модель, существует функция: ")
st.code('''result = Название модели*.predict(test_x) ''')
st.write("Она возвращает векторы ответов, где каждое число - характеризует уверенность нейросети в том или ином варианте ответа, чем больше значение, тем вероятнее вариант. Пример использования: ")
st.code('''# Испытание обученной нейросети (задача - классификация)
names = [Название первого класса*,
      Название второго класса*,
      Название третьего класса*,
      ...]
result = Название модели*.predict(test_x)
for n in range(len(result)):
  imax = 0
  for i in range(len(names)):
    if result[n][i] > result[n][imax]:
      imax = i
  print("Предположение:", names[imax], "Ответ:", test_y[n])
''')
but6 = st.button("Пример с ирисами", key=6)
if(but6):
    st.code('''# Испытание обученной нейросети (задача - классификация)
    names = ['Iris-setosa',
          'Iris-versicolor',
          'Iris-virginica']
    result = iris_model.predict(test_x)
    for n in range(len(result)):
      imax = 0
      for i in range(len(names)):
        if result[n][i] > result[n][imax]:
          imax = i
      print("Предположение:", names[imax], "Ответ:", test_y[n])
    ''')
st.write("Вот и все, теперь осталось только сохранить вашу нейросеть: ")
st.code('''# Сохранение модели
Название модели*.save(Название файла*) ''')
but7 = st.button("Пример с ирисами", key=7)
if(but7):
    st.code('''# Сохранение модели
    iris_model.save("iris.h5") ''')
st.write("Скачать её можно через сессионное хранилище, и, в последствии, импортировать: ")
st.code('''# Импорт модели
model = tf.saved_model.load(Название файла*) ''')
but8 = st.button("Пример с ирисами", key=8)
if(but8):
    st.code('''# Импорт модели
    model = tf.saved_model.load("iris.h5") ''')

